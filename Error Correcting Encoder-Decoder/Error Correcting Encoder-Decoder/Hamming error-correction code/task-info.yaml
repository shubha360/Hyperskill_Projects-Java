type: edu
custom_name: stage5
files:
- name: src/correcter/Main.java
  visible: true
  text: "package correcter;\n\nimport java.io.*;\nimport java.util.Random;\nimport\
    \ java.util.Scanner;\n\npublic class Main {\n    public static void main(String[]\
    \ args) {\n\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"\
    Write a mode: \");\n        String mode = scanner.nextLine();\n\n        switch\
    \ (mode) {\n\n            case \"encode\":\n\n                try (FileInputStream\
    \ fileInputStream = new FileInputStream(\"send.txt\");\n                     FileOutputStream\
    \ fileOutputStream = new FileOutputStream(\"encoded.txt\")) {\n\n            \
    \        byte[] input =fileInputStream.readAllBytes();\n                    byte[]\
    \ output = bitLevelEncodingMechanism(input);\n                    fileOutputStream.write(output);\n\
    \n                } catch (IOException e) {\n                    e.printStackTrace();\n\
    \                }\n                break;\n\n            case \"send\":\n   \
    \             \n                try (FileInputStream fileInputStream = new FileInputStream(\"\
    encoded.txt\");\n                     FileOutputStream fileOutputStream = new\
    \ FileOutputStream(\"received.txt\")) {\n\n                    byte[] input =\
    \ fileInputStream.readAllBytes();\n                    byte[] output = bitLevelSendingMechanism(input);\n\
    \                    fileOutputStream.write(output);\n\n                } catch\
    \ (IOException e) {\n                    e.printStackTrace();\n              \
    \  }\n                break;\n\n            case \"decode\":\n\n             \
    \   try (FileInputStream fileInputStream = new FileInputStream(\"received.txt\"\
    );\n                FileOutputStream fileOutputStream = new FileOutputStream(\"\
    decoded.txt\")) {\n\n                    byte[] input = fileInputStream.readAllBytes();\n\
    \                    byte[] output = bitLevelDecodingMechanism(input);\n     \
    \               fileOutputStream.write(output);\n\n                } catch (IOException\
    \ e) {\n                    e.printStackTrace();\n                }\n        \
    \        break;\n        }\n    }\n\n    static byte[] bitLevelEncodingMechanism(byte[]\
    \ input) {\n\n        StringBuilder binaryRepresentation = new StringBuilder();\n\
    \n        // Transforming input into binary\n        for (byte b : input) {\n\
    \            StringBuilder bin = to8bitBinary(b);\n            binaryRepresentation.append(bin);\n\
    \        }\n\n        // Starting to work with main output\n        StringBuilder\
    \ encodedOutput = new StringBuilder();\n        int parity = 0;\n        int flag\
    \ = 0;\n        int i;\n\n        for (i = 0; i < binaryRepresentation.length();\
    \ i++) {\n\n            char currentBit = binaryRepresentation.charAt(i);\n\n\
    \            encodedOutput.append(String.valueOf(currentBit).repeat(2));\n\n \
    \           parity += currentBit - 48;\n            flag++;\n\n            if\
    \ (flag == 3) {\n\n                encodedOutput.append(String.valueOf(parity\
    \ % 2).repeat(2));\n                parity = 0;\n                flag = 0;\n \
    \           }\n\n            if (i == binaryRepresentation.length() - 1 && flag\
    \ < 3) {\n\n                while (flag < 3) {\n\n                    encodedOutput.append(\"\
    0\".repeat(2));\n                    parity += 0;\n                    flag++;\n\
    \                }\n                encodedOutput.append(String.valueOf(parity\
    \ % 2).repeat(2));\n            }\n        }\n\n        byte[] output = new byte[encodedOutput.length()\
    \ / 8];\n\n        for (int j = 0; j < output.length; j++) {\n            output[j]\
    \ = (byte) Integer.parseInt(encodedOutput.substring(j * 8, (j + 1) * 8), 2);\n\
    \        }\n\n        return output;\n    }\n\n    static byte[] bitLevelSendingMechanism(byte[]\
    \ input) {\n\n        byte[] output = new byte[input.length];\n\n        int i\
    \ = 0;\n        for (byte b : input) {\n\n            StringBuilder binary = to8bitBinary(b);\n\
    \n            Random random = new Random();\n            int target = random.nextInt(8);\n\
    \n            binary = binary.charAt(target) == '1' ? binary.replace(target, target\
    \ + 1, \"0\") : binary.replace(target, target + 1, \"1\");\n            output[i]\
    \ = (byte) Integer.parseInt(binary.toString(), 2);\n            i++;\n       \
    \ }\n\n        return output;\n    }\n\n    static byte[] bitLevelDecodingMechanism(byte[]\
    \ input) {\n\n        StringBuilder binaryRepresentation = new StringBuilder();\n\
    \n        // Transforming input into 8-bit binary\n        for (byte b : input)\
    \ {\n\n            StringBuilder binary = to8bitBinary(b);\n            binaryRepresentation.append(binary);\n\
    \        }\n\n        StringBuilder decodedInput = new StringBuilder();\n\n  \
    \      for (int i = 0; i < binaryRepresentation.length(); i += 8) {\n\n      \
    \      String currentByte = binaryRepresentation.substring(i, i + 8);\n\n    \
    \        for (int j = 0; j < currentByte.length() - 2; j += 2) {\n\n         \
    \       if (currentByte.charAt(j) == currentByte.charAt(j + 1)) {\n          \
    \          decodedInput.append(currentByte.charAt(j));\n                } else\
    \ {\n\n                    int parity = currentByte.charAt(7) - 48;\n        \
    \            if (j == 0) {\n\n                        if (((currentByte.charAt(2)\
    \ - 48) + (currentByte.charAt(4) - 48)) % 2 == parity) {\n                   \
    \         decodedInput.append(\"0\");\n                        } else {\n    \
    \                        decodedInput.append(\"1\");\n                       \
    \ }\n                    } else if (j == 2) {\n\n                        if (((currentByte.charAt(0)\
    \ - 48) + (currentByte.charAt(4) - 48)) % 2 == parity) {\n                   \
    \         decodedInput.append(\"0\");\n                        } else {\n    \
    \                        decodedInput.append(\"1\");\n                       \
    \ }\n                    } else if (j == 4) {\n\n                        if (((currentByte.charAt(0)\
    \ - 48) + (currentByte.charAt(2) - 48)) % 2 == parity) {\n                   \
    \         decodedInput.append(\"0\");\n                        } else {\n    \
    \                        decodedInput.append(\"1\");\n                       \
    \ }\n                    }\n                }\n            }\n        }\n\n  \
    \      while (decodedInput.length() % 8 != 0) {\n            decodedInput.deleteCharAt(decodedInput.length()\
    \ - 1);\n        }\n\n        byte[] output = new byte[decodedInput.length() /\
    \ 8];\n\n        for (int j = 0; j < output.length; j++) {\n            output[j]\
    \ = (byte) Integer.parseInt(decodedInput.substring(j * 8, (j + 1) * 8), 2);\n\
    \        }\n\n        return output;\n    }\n\n    static StringBuilder to8bitBinary(Byte\
    \ data) {\n\n        StringBuilder binary = new StringBuilder(Integer.toBinaryString(data));\n\
    \n        if (binary.length() > 8) {\n            binary = new StringBuilder(binary.substring(binary.length()\
    \ - 8));\n        } else if (binary.length() < 8) {\n\n            while (binary.length()\
    \ < 8) {\n                binary = binary.insert(0, \"0\");\n            }\n \
    \       }\n        return binary;\n    }\n\n    static StringBuilder convertBits(StringBuilder\
    \ input) {\n\n        StringBuilder convertedString = new StringBuilder(input.length());\n\
    \        Random random = new Random();\n\n        for (int i = 0; i < input.length();\
    \ i++) {\n\n            StringBuilder binary = new StringBuilder(Integer.toBinaryString(input.charAt(i)));\n\
    \n            int target = random.nextInt(binary.length() - 1) + 1;\n\n      \
    \      binary = binary.charAt(target) == '1' ? binary.replace(target, target +\
    \ 1, \"0\") : binary.replace(target, target + 1, \"1\");\n\n            convertedString.append((char)\
    \ ((int) Integer.valueOf(binary.toString(), 2)));\n        }\n        return convertedString;\n\
    \    }\n\n    static StringBuilder sendOverPoorConnection(StringBuilder input)\
    \ {\n\n        Random random = new Random();\n        int i = 0;\n\n        while\
    \ (i < input.length()) {\n\n            int j = random.nextInt(3);\n\n       \
    \     if (i + j > input.length()) {\n                break;\n            }\n\n\
    \            int characterIndex = random.nextInt(63);\n\n            input.replace(i\
    \ + j, i + j + 1, String.valueOf(characterGenerator(characterIndex)));\n     \
    \       i += 3;\n        }\n        return input;\n    }\n\n    static StringBuilder\
    \ encode(StringBuilder input) {\n\n        StringBuilder encodedMessage = new\
    \ StringBuilder(input.length() * 3);\n\n        for (int i = 0; i < input.length();\
    \ i++) {\n            for (int j = 0; j < 3; j++) {\n                encodedMessage.append(input.charAt(i));\n\
    \            }\n        }\n        return encodedMessage;\n    }\n\n    static\
    \ StringBuilder decode(StringBuilder input) {\n\n        StringBuilder decodedMessage\
    \ = new StringBuilder(input.length() / 3);\n\n        for (int i = 0; i < input.length();\
    \ i += 3) {\n\n            if (input.charAt(i) == input.charAt(i + 1) || input.charAt(i)\
    \ == input.charAt(i + 2)) {\n                decodedMessage.append(input.charAt(i));\n\
    \            } else {\n                decodedMessage.append(input.charAt(i +\
    \ 1));\n            }\n        }\n        return decodedMessage;\n    }\n\n  \
    \  static char characterGenerator(int index) {\n\n        if (index < 26) {\n\
    \            return (char) ('A' + index);\n        } else if (index < 52) {\n\
    \            return (char) ('a' + (index - 26));\n        } else if (index ==\
    \ 52) {\n            return ' ';\n        } else {\n            return (char)\
    \ ('0' + (index - 53));\n        }\n    }\n}\n"
  learner_created: false
- name: received.txt
  visible: true
  text: "7\n2�\x02���\a�\bp����>���1�Ӏ44��=\x01�\x10,�\x01��\x1f��8C�г��\x02=\x1f�\
    �\a��L8\x1c��\x0eL�\x02\a \x01�\v\x0e��>=��\n��O\x04"
  learner_created: false
- name: encoded.txt
  visible: true
  text: "3\x0f3ð\0ÌðÃ\x0f\0\0ððÌÌÿ<ÃÃð3ÃÃ\0<<ðð<\0Ã\0<Ì\0ðÃ\x0fÃÌ<Ãðð3ÃÃ\0<\x0fÃÿ\x0f\
    \x0fÃÌ<<Ãð\x0fÌÌ\0\x0f\0\0ð\x0f\x0fðÌ<<Ãÿ\x0fÃÃ\x0f\0"
  learner_created: false
- name: decoded.txt
  visible: true
  text: Eat more of these french buns!
  learner_created: false
- name: test/CorrecterTest.java
  visible: false
  text: |+
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.TestCase;

    import java.io.File;
    import java.io.FileInputStream;
    import java.io.FileNotFoundException;
    import java.io.IOException;
    import java.util.ArrayList;
    import java.util.List;

    class TestClue {
        String input;
        String fileContent;

        TestClue(String input, String fileContent) {
            this.input = input;
            this.fileContent = fileContent;
        }
    }

    public class CorrecterTest extends StageTest<TestClue> {

        private static File received = null;
        private static File encoded = null;
        private static File decoded = null;

        @Override
        public List<TestCase<TestClue>> generate() {
            TestClue[] testClues = new TestClue[]{
                new TestClue("encode", "Eat more of these french buns!"),
                new TestClue("send",   "Eat more of these french buns!"),
                new TestClue("decode", "Eat more of these french buns!"),

                new TestClue("encode", "$ome rand0m messAge"),
                new TestClue("send",   "$ome rand0m messAge"),
                new TestClue("decode", "$ome rand0m messAge"),

                new TestClue("encode", "better call Saul 555-00-73!"),
                new TestClue("send",   "better call Saul 555-00-73!"),
                new TestClue("decode", "better call Saul 555-00-73!"),

                new TestClue("encode", "5548172 6548 225147 23656595 5155"),
                new TestClue("send",   "5548172 6548 225147 23656595 5155"),
                new TestClue("decode", "5548172 6548 225147 23656595 5155"),
            };

            List<TestCase<TestClue>> result = new ArrayList<>();

            for (int i = 0; i < testClues.length; i++) {
                result.add(new TestCase<TestClue>()
                    .setAttach(testClues[i])
                    .setInput(testClues[i].input)
                    .addFile("send.txt", testClues[i].fileContent));
            }

            return result;
        }

        @Override
        public CheckResult check(String reply, TestClue clue) {
            String path = System.getProperty("user.dir");

            received = null;
            encoded = null;
            decoded = null;

            searchReceived();
            searchEncoded();
            searchDecoded();

            String correctFileBinary = toBinary(clue.fileContent.getBytes());
            String correctFileEncoded = encodeFile(correctFileBinary);

            String action = clue.input;

            if (action.equals("encode")) {

                if (encoded == null) {
                    return new CheckResult(false,
                        "Can't find encoded.txt file. " +
                            "Make sure your program writes it down or " +
                            "make sure the name of file is correct.");
                }

                byte[] encodedContent;
                FileInputStream encodedStream;

                try {
                    encodedStream = new FileInputStream(encoded);
                } catch (FileNotFoundException e) {
                    return new CheckResult(false,
                        "Can't find received.txt file. " +
                            "Make sure your program writes it down or " +
                            "make sure the name of file is correct.");
                }

                try {
                    encodedContent = encodedStream.readAllBytes();
                } catch (IOException e) {
                    e.printStackTrace();
                    throw new RuntimeException("Can't read the file");
                }

                String encodedBinary = toBinary(encodedContent);

                return new CheckResult(encodedBinary.equals(correctFileEncoded));
            }

            if (action.equals("send")) {

                if (received == null) {
                    return new CheckResult(false,
                        "Can't find received.txt file. " +
                            "Make sure your program writes it " +
                            "down or make sure the name of file is correct.");
                }

                byte[] receivedContent;

                FileInputStream receivedStream;

                try {
                    receivedStream = new FileInputStream(received);
                } catch (FileNotFoundException e) {
                    return new CheckResult(false,
                        "Can't find received.txt file. " +
                            "Make sure your program writes it down or " +
                            "make sure the name of file is correct.");
                }

                try {
                    receivedContent = receivedStream.readAllBytes();
                } catch (IOException e) {
                    e.printStackTrace();
                    throw new RuntimeException("Can't read the file");
                }

                String receivedBinary = toBinary(receivedContent);


                return checkDifference(receivedBinary, correctFileEncoded);
            }



            if (action.equals("decode")) {

                if (decoded == null) {
                    return new CheckResult(false,
                        "Can't find decoded.txt file. " +
                            "Make sure your program writes it down or " +
                            "make sure the name of file is correct.");
                }

                byte[] decodedContent;


                FileInputStream decodedStream;

                try {
                    decodedStream = new FileInputStream(decoded);
                } catch (FileNotFoundException e) {
                    return new CheckResult(false,
                        "Can't find received.txt file. " +
                            "Make sure your program writes it down or " +
                            "make sure the name of file is correct.");
                }

                try {
                    decodedContent = decodedStream.readAllBytes();
                } catch (IOException e) {
                    e.printStackTrace();
                    throw new RuntimeException("Can't read the file");
                }

                String decodedBinary = toBinary(decodedContent);

                if (!decodedBinary.equals(correctFileBinary)) {
                    return new CheckResult(false, "The decoded text must match initial text!");
                }

                return CheckResult.correct();
            }

            throw new RuntimeException("Can't check the program");
        }

        private static String toBinary(byte[] bytes) {
            StringBuilder sb = new StringBuilder(bytes.length * Byte.SIZE);
            for (int i = 0; i < Byte.SIZE * bytes.length; i++) {
                sb.append((bytes[i / Byte.SIZE] << i % Byte.SIZE & 0x80) == 0 ? '0' : '1');
            }
            return sb.toString();
        }

        private static byte[] fromBinary(String s) {
            int sLen = s.length();
            byte[] toReturn = new byte[(sLen + Byte.SIZE - 1) / Byte.SIZE];
            char c;
            for (int i = 0; i < sLen; i++)
                if ((c = s.charAt(i)) == '1')
                    toReturn[i / Byte.SIZE] = (byte) (toReturn[i / Byte.SIZE] | (0x80 >>> (i % Byte.SIZE)));
                else if (c != '0')
                    throw new IllegalArgumentException();
            return toReturn;
        }

        private static void searchReceived() {
            File file = new File("received.txt");
            if (file.exists()) {
                received = file;
            }
        }

        private static void searchEncoded() {
            File file = new File("encoded.txt");
            if (file.exists()) {
                encoded = file;
            }
        }

        private static void searchDecoded() {
            File file = new File("decoded.txt");
            if (file.exists()) {
                decoded = file;
            }
        }

        private String encodeFile(String binaryString) {

            String encoded = "";

            for (int i = 0; i < binaryString.length(); i += 4) {

                if (i + 4 > binaryString.length()) {
                    throw new RuntimeException("Can't decode binary data");
                }

                int startSubIndex = i;
                int stopSubIndex = i + 4;

                String currSub = binaryString.substring(startSubIndex, stopSubIndex);

                String encodedPart;

                int parityBit1 = 0;
                int parityBit2 = 0;
                int parityBit4 = 0;

                if (currSub.charAt(0) == '1') {
                    parityBit1++;
                    parityBit2++;
                }

                if (currSub.charAt(1) == '1') {
                    parityBit1++;
                    parityBit4++;
                }

                if (currSub.charAt(2) == '1') {
                    parityBit2++;
                    parityBit4++;
                }

                if (currSub.charAt(3) == '1') {
                    parityBit1++;
                    parityBit2++;
                    parityBit4++;
                }

                encodedPart =
                    (parityBit1 % 2 == 1? "1": "0") +
                    (parityBit2 % 2 == 1? "1": "0") +
                    currSub.charAt(0) +
                    (parityBit4 % 2 == 1? "1": "0") +
                    currSub.charAt(1) +
                    currSub.charAt(2) +
                    currSub.charAt(3) +
                    "0";

                encoded += encodedPart;
            }

            return encoded;
        }

        private CheckResult checkDifference(String output, String correct) {
            if (output.isEmpty() && correct.isEmpty()) return CheckResult.correct();

            if (output.length() != correct.length()) {
                return new CheckResult(false,
                    "The program was expected to output " +
                        correct.length() / 8 +
                        " bytes, but output " +
                        output.length() / 8);
            }

            for (int i = 0; i < output.length(); i += 8) {
                String currOutputByte = output.substring(i, i+8);
                String currCorrectByte = correct.substring(i, i+8);

                int difference = 0;
                for (int j = 0; j < currCorrectByte.length(); j++) {
                    char currOutputBit = currOutputByte.charAt(j);
                    char currCorrectBit = currCorrectByte.charAt(j);

                    if (currCorrectBit != currOutputBit) {
                        difference++;
                    }
                }

                if (difference == 0) {
                    return new CheckResult(false,
                        "One of bytes from the input stayed the same but should be changed");
                }

                if (difference != 1) {
                    return new CheckResult(false,
                        "One of bytes from the input was changes in more than one bit");
                }
            }

            return CheckResult.correct();
        }
    }

  learner_created: false
feedback_link: https://hyperskill.org/projects/58/stages/316/implement#comment
status: Unchecked
record: -1
